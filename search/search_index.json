{
    "docs": [
        {
            "location": "/",
            "text": "../../README.md",
            "title": "Home"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-config-aggregator\n is a lightweight library for managing application\nconfiguration. It was designed to be flexible in dev environments and fast in\nproduction.\n\n\nIt supports loading and merging configuration from multiple sources: PHP files,\narrays, or INI/YAML/XML files (using \nzend-config\n)\n\n\nIt also provides the ability to post process the merged configuration to apply e.g. parameter\nhandling like \nsymfony/dependency-injection\n\n\nBasic usage\n\n\nThe standalone \nConfigAggregator\n can be used to merge PHP-based configuration files:\n\n\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator([\n    new PhpFileProvider('*.global.php'),\n]);\n\nvar_dump($aggregator->getMergedConfig());\n\n\n\nUsing this provider, each file should return a PHP array:\n\n\n// db.global.php\nreturn [\n    'db' => [\n        'dsn' => 'mysql:...',\n    ],\n];\n\n// cache.global.php\nreturn [\n    'cache_storage' => 'redis',\n    'redis' => [ ... ],\n];\n\n\n\nResult:\n\n\narray(3) {\n  'db' =>\n  array(1) {\n    'dsn' =>\n    string(9) \"mysql:...\"\n  }\n  'cache_storage' =>\n  string(5) \"redis\"\n  'redis' =>\n  array(0) {\n     ...\n  }\n}\n\n\n\nConfiguration is merged in the same order as it is passed, with later entries having precedence.\n\n\nTogether with \nzend-config\n, \nzend-config-aggregator\n can be also used to load\nconfiguration in different formats, including YAML, JSON, XML, or INI:\n\n\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\ZendConfigProvider;\n\n$aggregator = new ConfigAggregator([\n    new ZendConfigProvider('config/*.{json,yaml,php}'),\n]);\n\n\n\nYou can also supply \npost processors\n for\nconfiguration. These are PHP callables that accept the merged configuration as\nan argument, do something with it, and return configuration on completion. This\ncould be used, for example, to allow templating parameters that are used in\nmultiple locations and resolving them to a single value later.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-config-aggregator  is a lightweight library for managing application\nconfiguration. It was designed to be flexible in dev environments and fast in\nproduction.  It supports loading and merging configuration from multiple sources: PHP files,\narrays, or INI/YAML/XML files (using  zend-config )  It also provides the ability to post process the merged configuration to apply e.g. parameter\nhandling like  symfony/dependency-injection",
            "title": "Introduction"
        },
        {
            "location": "/intro/#basic-usage",
            "text": "The standalone  ConfigAggregator  can be used to merge PHP-based configuration files:  use Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator([\n    new PhpFileProvider('*.global.php'),\n]);\n\nvar_dump($aggregator->getMergedConfig());  Using this provider, each file should return a PHP array:  // db.global.php\nreturn [\n    'db' => [\n        'dsn' => 'mysql:...',\n    ],\n];\n\n// cache.global.php\nreturn [\n    'cache_storage' => 'redis',\n    'redis' => [ ... ],\n];  Result:  array(3) {\n  'db' =>\n  array(1) {\n    'dsn' =>\n    string(9) \"mysql:...\"\n  }\n  'cache_storage' =>\n  string(5) \"redis\"\n  'redis' =>\n  array(0) {\n     ...\n  }\n}  Configuration is merged in the same order as it is passed, with later entries having precedence.  Together with  zend-config ,  zend-config-aggregator  can be also used to load\nconfiguration in different formats, including YAML, JSON, XML, or INI:  use Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\ZendConfigProvider;\n\n$aggregator = new ConfigAggregator([\n    new ZendConfigProvider('config/*.{json,yaml,php}'),\n]);  You can also supply  post processors  for\nconfiguration. These are PHP callables that accept the merged configuration as\nan argument, do something with it, and return configuration on completion. This\ncould be used, for example, to allow templating parameters that are used in\nmultiple locations and resolving them to a single value later.",
            "title": "Basic usage"
        },
        {
            "location": "/config-providers/",
            "text": "Config providers\n\n\nThe \nConfigAggregator\n works by aggregating \"config providers\" passed to its\nconstructor.  Each provider should be a callable, returning a configuration\narray (or a PHP generator) to be merged.\n\n\n$aggregator = new ConfigAggregator([\n    function () {\n        return ['foo' => 'bar'];\n    },\n    new PhpFileProvider('*.global.php'),\n]);\nvar_dump($aggregator->getMergedConfig());\n\n\n\nIf the provider is a class name, the aggregator automatically instantiates it\nbefore invoking it; as such, any class name you use as a config provider \nmust\n\nalso define \n__invoke()\n, and that method \nmust\n return an array.\n\n\nThis can be used to mimic the Zend Framework module system: you can specify a\nlist of config providers from different packages, and aggregated configuration\nwill be available to your application.\n\n\nAs a library owner, you can distribute your own configuration providers that\nprovide default values for use with your library.\n\n\nAs an example:\n\n\nclass ApplicationConfig\n{\n    public function __invoke()\n    {\n        return ['foo' => 'bar'];\n    }\n}\n\n$aggregator = new ConfigAggregator([\n    ApplicationConfig::class,\n    new PhpFileProvider('*.global.php'),\n]);\nvar_dump($aggregator->getMergedConfig());\n\n\n\nOutput from both examples will be the same:\n\n\narray(4) {\n  'foo' =>\n  string(3) \"bar\"\n  'db' =>\n  array(1) {\n    'dsn' =>\n    string(9) \"mysql:...\"\n  }\n  'cache_storage' =>\n  string(5) \"redis\"\n  'redis' =>\n  array(0) {\n  }\n}\n\n\n\nGenerators\n\n\nConfig providers can be written as generators. This way, a single callable can\nprovide multiple configurations:\n\n\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\Stdlib\\Glob;\n\n$aggregator = new ConfigAggregator([\n    function () {\n        foreach (Glob::glob('data/*.global.php', Glob::GLOB_BRACE) as $file) {\n            yield include $file;\n        }\n    },\n]);\nvar_dump($aggregator->getMergedConfig());\n\n\n\nThe \nPhpFileProvider\n is implemented as a generator.\n\n\nAvailable config providers\n\n\nPhpFileProvider\n\n\nLoads configuration from PHP files returning arrays, such as this one:\n\n\nreturn [\n    'db' => [\n        'dsn' => 'mysql:...',\n    ],\n];\n\n\n\nWildcards are supported:\n\n\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new PhpFileProvider('config/*.global.php'),\n    ]\n);\n\n\n\nThe example above will merge all matching files from the \nconfig/\n directory. If\nyou have files such as \napp.global.php\n or \ndatabase.global.php\n in that\ndirectory, they will be loaded using this above lines of code.\n\n\nThe provider also supports \nglobbing\n.  Globbing defaults to PHP's \nglob()\n\nfunction. However, if \nZend\\Stdlib\\Glob\n is available, it will use that to allow\nfor cross-platform glob patterns, including brace notation:\n\n'config/autoload/{{,*.}global,{,*.}local}.php'\n. Install\n\nzendframework/zend-stdlib\n to\nutilize this feature.\n\n\nZendConfigProvider\n\n\nSometimes using plain PHP files may be not enough; you may want to build your\nconfiguration from multiple files of different formats, such as INI, JSON, YAML,\nor XML.  zend-config-aggregator allows you to do so via its\n\nZendConfigProvider\n. This feature requires first installing zend-config:\n\n\n$ composer require zendframework/zend-config\n\n\n\nOnce installed, you may use as many \nZendConfigProvider\n instances as you need:\n\n\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\ZendConfigProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new ZendConfigProvider('*.global.json'),\n        new ZendConfigProvider('database.local.ini'),\n    ]\n);\n\n\n\nThese could even be combined into a single glob statement:\n\n\n$aggregator = new ConfigAggregator(\n    [\n        new ZendConfigProvider('*.global.json,database.local.ini'),\n    ]\n);\n\n\n\nZendConfigProvider\n accepts wildcards and globs, and autodetects the config\ntype based on file extension.\n\n\nSome config readers (in particular, YAML) may need additional dependencies;\nplease refer to \nthe zend-config manual\n\nfor more details.",
            "title": "Config Providers"
        },
        {
            "location": "/config-providers/#config-providers",
            "text": "The  ConfigAggregator  works by aggregating \"config providers\" passed to its\nconstructor.  Each provider should be a callable, returning a configuration\narray (or a PHP generator) to be merged.  $aggregator = new ConfigAggregator([\n    function () {\n        return ['foo' => 'bar'];\n    },\n    new PhpFileProvider('*.global.php'),\n]);\nvar_dump($aggregator->getMergedConfig());  If the provider is a class name, the aggregator automatically instantiates it\nbefore invoking it; as such, any class name you use as a config provider  must \nalso define  __invoke() , and that method  must  return an array.  This can be used to mimic the Zend Framework module system: you can specify a\nlist of config providers from different packages, and aggregated configuration\nwill be available to your application.  As a library owner, you can distribute your own configuration providers that\nprovide default values for use with your library.  As an example:  class ApplicationConfig\n{\n    public function __invoke()\n    {\n        return ['foo' => 'bar'];\n    }\n}\n\n$aggregator = new ConfigAggregator([\n    ApplicationConfig::class,\n    new PhpFileProvider('*.global.php'),\n]);\nvar_dump($aggregator->getMergedConfig());  Output from both examples will be the same:  array(4) {\n  'foo' =>\n  string(3) \"bar\"\n  'db' =>\n  array(1) {\n    'dsn' =>\n    string(9) \"mysql:...\"\n  }\n  'cache_storage' =>\n  string(5) \"redis\"\n  'redis' =>\n  array(0) {\n  }\n}",
            "title": "Config providers"
        },
        {
            "location": "/config-providers/#generators",
            "text": "Config providers can be written as generators. This way, a single callable can\nprovide multiple configurations:  use Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\Stdlib\\Glob;\n\n$aggregator = new ConfigAggregator([\n    function () {\n        foreach (Glob::glob('data/*.global.php', Glob::GLOB_BRACE) as $file) {\n            yield include $file;\n        }\n    },\n]);\nvar_dump($aggregator->getMergedConfig());  The  PhpFileProvider  is implemented as a generator.",
            "title": "Generators"
        },
        {
            "location": "/config-providers/#available-config-providers",
            "text": "",
            "title": "Available config providers"
        },
        {
            "location": "/config-providers/#phpfileprovider",
            "text": "Loads configuration from PHP files returning arrays, such as this one:  return [\n    'db' => [\n        'dsn' => 'mysql:...',\n    ],\n];  Wildcards are supported:  use Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new PhpFileProvider('config/*.global.php'),\n    ]\n);  The example above will merge all matching files from the  config/  directory. If\nyou have files such as  app.global.php  or  database.global.php  in that\ndirectory, they will be loaded using this above lines of code.  The provider also supports  globbing .  Globbing defaults to PHP's  glob() \nfunction. However, if  Zend\\Stdlib\\Glob  is available, it will use that to allow\nfor cross-platform glob patterns, including brace notation: 'config/autoload/{{,*.}global,{,*.}local}.php' . Install zendframework/zend-stdlib  to\nutilize this feature.",
            "title": "PhpFileProvider"
        },
        {
            "location": "/config-providers/#zendconfigprovider",
            "text": "Sometimes using plain PHP files may be not enough; you may want to build your\nconfiguration from multiple files of different formats, such as INI, JSON, YAML,\nor XML.  zend-config-aggregator allows you to do so via its ZendConfigProvider . This feature requires first installing zend-config:  $ composer require zendframework/zend-config  Once installed, you may use as many  ZendConfigProvider  instances as you need:  use Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\ZendConfigProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new ZendConfigProvider('*.global.json'),\n        new ZendConfigProvider('database.local.ini'),\n    ]\n);  These could even be combined into a single glob statement:  $aggregator = new ConfigAggregator(\n    [\n        new ZendConfigProvider('*.global.json,database.local.ini'),\n    ]\n);  ZendConfigProvider  accepts wildcards and globs, and autodetects the config\ntype based on file extension.  Some config readers (in particular, YAML) may need additional dependencies;\nplease refer to  the zend-config manual \nfor more details.",
            "title": "ZendConfigProvider"
        },
        {
            "location": "/config-post-processors/",
            "text": "Post processors\n\n\nThe \nConfigAggregator\n can apply post processors to the merged configuration by\naggregating \"config processors\" passed to its constructor. Each processor\nshould be a PHP \ncallable\n which consumes the merged configuration as its sole\nargument, and which then returns the processed configuration array.\n\n\n$providers = [\n    function () {\n        return ['foo' => 'bar'];\n    },\n    new PhpFileProvider('*.global.php'),\n];\n\n$processors = [\n    function (array $config) {\n        return $config + ['post-processed' => true];\n    },\n];\n\n$aggregator = new ConfigAggregator($providers, null, $processors);\nvar_dump($aggregator->getMergedConfig());\n\n\n\nOutput from the example:\n\n\narray(2) {\n  'foo' =>\n  string(3) \"bar\"\n  'post-processed' =>\n  bool(true)\n}\n\n\n\nIf the processor is a class name, the aggregator automatically instantiates it\nbefore invoking it; as such, any class name you use as a config provider\n\nmust\n also define \n__invoke()\n, and that method \nmust\n return an array and\n\nmay\n consume the merged configuration as a parameter.\n\n\nPost processors can be used to mimic tools such as the \nSymfony configuration\nparameter system\n.\nAs an example, you can specify a config processor which consumes the merged\nconfiguration and resolves templated parameters to other parameters within your\nconfiguration.\n\n\nPost processor examples\n\n\nSymfony ParameterBag Post Processor\n\n\nThe following example resolves templated parameters to either other parameters\nwithin your configuration, or a static set of substitutions. Templated\nparameters have the format \n%<config_key>%\n; \n.\n characters indicate an\nadditional level of nesting. If you want to provide configuration parameters\nwith \n%\n in the value, you must escape any occurences of \n%\n by using another\n\n%\n; as examples, \n%%bar\n or \n%%foo%%\n.\n\n\nIn the following example, we define a provider that returns a nested array of\nconfiguration. We then define additional parameters and pass them to a \nSymfony DI \nParameterBag\n, which we develop a closure over. This closure checks\nfor parameters in the passed configuration itself, and then attempts to resolve\nall configuration values based on the parameters in the \nParameterBag\n.\n\n\n\n$provider = [\n    function () {\n        return [\n            'session' => [\n                'cookie_domain' => '%cookie_domain%',\n            ],\n            'tracking' => [\n                'cookie_domain' => '%cookie_domain%',\n            ],\n            // Will be converted to %foo% after resolving\n            'config_parameter_with_percent' => '%%foo%%',\n        ];\n    },\n];\n\n$parameters = [\n    'cookie_domain' => 'example.com',\n];\n\n$bag = new \\Symfony\\Component\\DependencyInjection\\ParameterBag\\ParameterBag($parameters);\n$resolver = function (array $config) use ($bag) {\n    $parametersFromConfiguration = isset($config['parameters']) ? $config['parameters'] : [];\n    $bag->add($parametersFromConfiguration);\n\n    // Resolve parameters which probably base on parameters\n    $bag->resolve();\n\n    // Replace all parameters within the configuration\n    $resolved = $bag->resolveValue($config);\n    $resolved['parameters'] = $bag->all();\n\n    return $bag->unescapeValue($resolved);\n};\n\n$aggregator = new ConfigAggregator($provider, null, [\n    $resolver,\n]);\n\nvar_dump($aggregator->getMergedConfig());\n\n\n\nThe above would result in the following when complete:\n\n\narray(2) {\n  'session' =>\n  array(1) {\n    'cookie_domain' =>\n    string(11) \"example.com\"\n  }\n  'tracking' =>\n  array(1) {\n    'cookie_domain' =>\n    string(11) \"example.com\"\n  }\n  'config_parameter_with_percent' =>\n    string(7) \"%foo%\"\n  }\n  'parameters' =>\n  array(1) {\n    'cookie_domain' =>\n    string(11) \"example.com\"\n  }\n}",
            "title": "Post Processors"
        },
        {
            "location": "/config-post-processors/#post-processors",
            "text": "The  ConfigAggregator  can apply post processors to the merged configuration by\naggregating \"config processors\" passed to its constructor. Each processor\nshould be a PHP  callable  which consumes the merged configuration as its sole\nargument, and which then returns the processed configuration array.  $providers = [\n    function () {\n        return ['foo' => 'bar'];\n    },\n    new PhpFileProvider('*.global.php'),\n];\n\n$processors = [\n    function (array $config) {\n        return $config + ['post-processed' => true];\n    },\n];\n\n$aggregator = new ConfigAggregator($providers, null, $processors);\nvar_dump($aggregator->getMergedConfig());  Output from the example:  array(2) {\n  'foo' =>\n  string(3) \"bar\"\n  'post-processed' =>\n  bool(true)\n}  If the processor is a class name, the aggregator automatically instantiates it\nbefore invoking it; as such, any class name you use as a config provider must  also define  __invoke() , and that method  must  return an array and may  consume the merged configuration as a parameter.  Post processors can be used to mimic tools such as the  Symfony configuration\nparameter system .\nAs an example, you can specify a config processor which consumes the merged\nconfiguration and resolves templated parameters to other parameters within your\nconfiguration.",
            "title": "Post processors"
        },
        {
            "location": "/config-post-processors/#post-processor-examples",
            "text": "",
            "title": "Post processor examples"
        },
        {
            "location": "/config-post-processors/#symfony-parameterbag-post-processor",
            "text": "The following example resolves templated parameters to either other parameters\nwithin your configuration, or a static set of substitutions. Templated\nparameters have the format  %<config_key>% ;  .  characters indicate an\nadditional level of nesting. If you want to provide configuration parameters\nwith  %  in the value, you must escape any occurences of  %  by using another % ; as examples,  %%bar  or  %%foo%% .  In the following example, we define a provider that returns a nested array of\nconfiguration. We then define additional parameters and pass them to a \nSymfony DI  ParameterBag , which we develop a closure over. This closure checks\nfor parameters in the passed configuration itself, and then attempts to resolve\nall configuration values based on the parameters in the  ParameterBag .  \n$provider = [\n    function () {\n        return [\n            'session' => [\n                'cookie_domain' => '%cookie_domain%',\n            ],\n            'tracking' => [\n                'cookie_domain' => '%cookie_domain%',\n            ],\n            // Will be converted to %foo% after resolving\n            'config_parameter_with_percent' => '%%foo%%',\n        ];\n    },\n];\n\n$parameters = [\n    'cookie_domain' => 'example.com',\n];\n\n$bag = new \\Symfony\\Component\\DependencyInjection\\ParameterBag\\ParameterBag($parameters);\n$resolver = function (array $config) use ($bag) {\n    $parametersFromConfiguration = isset($config['parameters']) ? $config['parameters'] : [];\n    $bag->add($parametersFromConfiguration);\n\n    // Resolve parameters which probably base on parameters\n    $bag->resolve();\n\n    // Replace all parameters within the configuration\n    $resolved = $bag->resolveValue($config);\n    $resolved['parameters'] = $bag->all();\n\n    return $bag->unescapeValue($resolved);\n};\n\n$aggregator = new ConfigAggregator($provider, null, [\n    $resolver,\n]);\n\nvar_dump($aggregator->getMergedConfig());  The above would result in the following when complete:  array(2) {\n  'session' =>\n  array(1) {\n    'cookie_domain' =>\n    string(11) \"example.com\"\n  }\n  'tracking' =>\n  array(1) {\n    'cookie_domain' =>\n    string(11) \"example.com\"\n  }\n  'config_parameter_with_percent' =>\n    string(7) \"%foo%\"\n  }\n  'parameters' =>\n  array(1) {\n    'cookie_domain' =>\n    string(11) \"example.com\"\n  }\n}",
            "title": "Symfony ParameterBag Post Processor"
        },
        {
            "location": "/caching/",
            "text": "Caching\n\n\nMerging configuration on every request is not performant, particularly when\nusing many configuration files. As such, zend-config-aggregator also\nprovides the ability to enable a filesystem-based configuration cache.\n\n\nTo enable the configuration cache, pass a cache file name as the second\nparameter to the \nConfigAggregator\n constructor:\n\n\nuse Zend\\ConfigAggregator\\ArrayProvider;\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new ArrayProvider([ConfigAggregator::ENABLE_CACHE => true]),\n        new PhpFileProvider('*.global.php'),\n    ],\n    'data/config-cache.php'\n);\n\n\n\nWhen a cache file is specified, you will also need to add the\n\nconfig_cache_enabled\n key (which you can also specify via the\n\nConfigAggregator::ENABLE_CACHE\n constant) somewhere within one of your\nconfiguration providers, and set it to boolean \ntrue\n. Using this approach, if\nyou were to use the globbing pattern \n{{,*.}global,{,*.}local}.php\n (or similar)\nwith the \nPhpFileProvider\n, you could drop a file named \nenable-cache.local.php\n\ninto your production deployment with the following contents in order to enable\nconfiguration caching in production:\n\n\n<?php\nuse Zend\\ConfigAggregator\\ConfigAggregator;\n\nreturn [\n    ConfigAggregator::ENABLE_CACHE => true,\n];\n\n\n\nWhen caching is enabled, the \nConfigAggregator\n does not iterate config\nproviders. Because of that it is very fast, but after it is enabled, you cannot\nmake any changes to configuration without clearing the cache. \nCaching should\nbe used only in a production environment\n, and your deployment process should\nclear the cache.",
            "title": "Caching"
        },
        {
            "location": "/caching/#caching",
            "text": "Merging configuration on every request is not performant, particularly when\nusing many configuration files. As such, zend-config-aggregator also\nprovides the ability to enable a filesystem-based configuration cache.  To enable the configuration cache, pass a cache file name as the second\nparameter to the  ConfigAggregator  constructor:  use Zend\\ConfigAggregator\\ArrayProvider;\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new ArrayProvider([ConfigAggregator::ENABLE_CACHE => true]),\n        new PhpFileProvider('*.global.php'),\n    ],\n    'data/config-cache.php'\n);  When a cache file is specified, you will also need to add the config_cache_enabled  key (which you can also specify via the ConfigAggregator::ENABLE_CACHE  constant) somewhere within one of your\nconfiguration providers, and set it to boolean  true . Using this approach, if\nyou were to use the globbing pattern  {{,*.}global,{,*.}local}.php  (or similar)\nwith the  PhpFileProvider , you could drop a file named  enable-cache.local.php \ninto your production deployment with the following contents in order to enable\nconfiguration caching in production:  <?php\nuse Zend\\ConfigAggregator\\ConfigAggregator;\n\nreturn [\n    ConfigAggregator::ENABLE_CACHE => true,\n];  When caching is enabled, the  ConfigAggregator  does not iterate config\nproviders. Because of that it is very fast, but after it is enabled, you cannot\nmake any changes to configuration without clearing the cache.  Caching should\nbe used only in a production environment , and your deployment process should\nclear the cache.",
            "title": "Caching"
        }
    ]
}