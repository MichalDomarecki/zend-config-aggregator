{
    "docs": [
        {
            "location": "/",
            "text": "../../README.md",
            "title": "Home"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-config-aggregator\n is a lightweight library for managing application\nconfiguration. It was designed to be flexible in dev environments and fast in\nproduction.\n\n\nIt supports loading and merging configuration from multiple sources: PHP files,\narrays, or INI/YAML/XML files (using \nzend-config\n)\n\n\nBasic usage\n\n\nThe standalone \nConfigAggregator\n can be used to merge PHP-based configuration files: \n\n\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator([\n    new PhpFileProvider('*.global.php'),\n]);\n\nvar_dump($aggregator->getMergedConfig());\n\n\n\n\nUsing this provider, each file should return a PHP array:\n\n\n// db.global.php\nreturn [\n    'db' => [\n        'dsn' => 'mysql:...',\n    ],    \n];\n\n// cache.global.php\nreturn [\n    'cache_storage' => 'redis',\n    'redis' => [ ... ],\n];\n\n\n\n\nResult:\n\n\narray(3) {\n  'db' =>\n  array(1) {\n    'dsn' =>\n    string(9) \"mysql:...\"\n  }\n  'cache_storage' =>\n  string(5) \"redis\"\n  'redis' =>\n  array(0) {\n     ...\n  }\n}\n\n\n\n\nConfiguration is merged in the same order as it is passed, with later entries having precedence.\n\n\nTogether with \nzend-config\n, \nzend-config-aggregator\n can be also used to load\nconfiguration in different formats, including YAML, JSON, XML, or INI:\n\n\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\ZendConfigProvider;\n\n$aggregator = new ConfigAggregator([\n    new ZendConfigProvider('config/*.{json,yaml,php}'),\n]);",
            "title": "Introduction"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-config-aggregator  is a lightweight library for managing application\nconfiguration. It was designed to be flexible in dev environments and fast in\nproduction.  It supports loading and merging configuration from multiple sources: PHP files,\narrays, or INI/YAML/XML files (using  zend-config )",
            "title": "Introduction"
        },
        {
            "location": "/intro/#basic-usage",
            "text": "The standalone  ConfigAggregator  can be used to merge PHP-based configuration files:   use Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator([\n    new PhpFileProvider('*.global.php'),\n]);\n\nvar_dump($aggregator->getMergedConfig());  Using this provider, each file should return a PHP array:  // db.global.php\nreturn [\n    'db' => [\n        'dsn' => 'mysql:...',\n    ],    \n];\n\n// cache.global.php\nreturn [\n    'cache_storage' => 'redis',\n    'redis' => [ ... ],\n];  Result:  array(3) {\n  'db' =>\n  array(1) {\n    'dsn' =>\n    string(9) \"mysql:...\"\n  }\n  'cache_storage' =>\n  string(5) \"redis\"\n  'redis' =>\n  array(0) {\n     ...\n  }\n}  Configuration is merged in the same order as it is passed, with later entries having precedence.  Together with  zend-config ,  zend-config-aggregator  can be also used to load\nconfiguration in different formats, including YAML, JSON, XML, or INI:  use Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\ZendConfigProvider;\n\n$aggregator = new ConfigAggregator([\n    new ZendConfigProvider('config/*.{json,yaml,php}'),\n]);",
            "title": "Basic usage"
        },
        {
            "location": "/config-providers/",
            "text": "Config providers\n\n\nThe \nConfigAggregator\n works by aggregating \"config providers\" passed to its\nconstructor.  Each provider should be a callable, returning a configuration\narray (or a PHP generator) to be merged.\n\n\n$aggregator = new ConfigAggregator([\n    function () {\n        return ['foo' => 'bar'];\n    },\n    new PhpFileProvider('*.global.php'),\n]);\nvar_dump($aggregator->getMergedConfig());\n\n\n\n\nIf the provider is a class name, the aggregator automatically instantiates it\nbefore invoking it; as such, any class name you use as a config provider \nmust\n\nalso define \n__invoke()\n, and that method \nmust\n return an array.\n\n\nThis can be used to mimic the Zend Framework module system: you can specify a\nlist of config providers from different packages, and aggregated configuration\nwill be available to your application.\n\n\nAs a library owner, you can distribute your own configuration providers that\nprovide default values for use with your library.\n\n\nAs an example:\n\n\nclass ApplicationConfig\n{\n    public function __invoke()\n    {\n        return ['foo' => 'bar'];\n    }\n}\n\n$aggregator = new ConfigAggregator([\n    ApplicationConfig::class,\n    new PhpFileProvider('*.global.php'),\n]);\nvar_dump($aggregator->getMergedConfig());\n\n\n\n\nOutput from both examples will be the same:\n\n\narray(4) {\n  'foo' =>\n  string(3) \"bar\"\n  'db' =>\n  array(1) {\n    'dsn' =>\n    string(9) \"mysql:...\"\n  }\n  'cache_storage' =>\n  string(5) \"redis\"\n  'redis' =>\n  array(0) {\n  }\n}\n\n\n\n\nGenerators\n\n\nConfig providers can be written as generators. This way, a single callable can\nprovide multiple configurations:\n\n\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\Stdlib\\Glob;\n\n$aggregator = new ConfigAggregator([\n    function () {\n        foreach (Glob::glob('data/*.global.php', Glob::GLOB_BRACE) as $file) {\n            yield include $file;\n        }\n    },\n]);\nvar_dump($aggregator->getMergedConfig());\n\n\n\n\nThe \nPhpFileProvider\n is implemented as a generator.\n\n\nAvailable config providers\n\n\nPhpFileProvider\n\n\nLoads configuration from PHP files returning arrays, such as this one:\n\n\nreturn [\n    'db' => [\n        'dsn' => 'mysql:...',\n    ],    \n];\n\n\n\n\nWildcards are supported:\n\n\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new PhpFileProvider('config/*.global.php'),        \n    ]\n);\n\n\n\n\nThe example above will merge all matching files from the \nconfig/\n directory. If\nyou have files such as \napp.global.php\n or \ndatabase.global.php\n in that\ndirectory, they will be loaded using this above lines of code.\n\n\nThe provider also supports \nglobbing\n.  Globbing defaults to PHP's \nglob()\n\nfunction. However, if \nZend\\Stdlib\\Glob\n is available, it will use that to allow\nfor cross-platform glob patterns, including brace notation:\n\n'config/autoload/{{,*.}global,{,*.}local}.php'\n. Install\n\nzendframework/zend-stdlib\n to\nutilize this feature.\n\n\nZendConfigProvider\n\n\nSometimes using plain PHP files may be not enough; you may want to build your\nconfiguration from multiple files of different formats, such as INI, JSON, YAML,\nor XML.  zend-config-aggregator allows you to do so via its\n\nZendConfigProvider\n. This feature requires first installing zend-config:\n\n\n$ composer require zendframework/zend-config\n\n\n\n\nOnce installed, you may use as many \nZendConfigProvider\n instances as you need:\n\n\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\ZendConfigProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new ZendConfigProvider('*.global.json'),\n        new ZendConfigProvider('database.local.ini'),\n    ]\n);\n\n\n\n\nThese could even be combined into a single glob statement:\n\n\n$aggregator = new ConfigAggregator(\n    [\n        new ZendConfigProvider('*.global.json,database.local.ini'),\n    ]\n);\n\n\n\n\nZendConfigProvider\n accepts wildcards and globs, and autodetects the config\ntype based on file extension. \n\n\nSome config readers (in particular, YAML) may need additional dependencies;\nplease refer to \nthe zend-config manual\n\nfor more details.",
            "title": "Config Providers"
        },
        {
            "location": "/config-providers/#config-providers",
            "text": "The  ConfigAggregator  works by aggregating \"config providers\" passed to its\nconstructor.  Each provider should be a callable, returning a configuration\narray (or a PHP generator) to be merged.  $aggregator = new ConfigAggregator([\n    function () {\n        return ['foo' => 'bar'];\n    },\n    new PhpFileProvider('*.global.php'),\n]);\nvar_dump($aggregator->getMergedConfig());  If the provider is a class name, the aggregator automatically instantiates it\nbefore invoking it; as such, any class name you use as a config provider  must \nalso define  __invoke() , and that method  must  return an array.  This can be used to mimic the Zend Framework module system: you can specify a\nlist of config providers from different packages, and aggregated configuration\nwill be available to your application.  As a library owner, you can distribute your own configuration providers that\nprovide default values for use with your library.  As an example:  class ApplicationConfig\n{\n    public function __invoke()\n    {\n        return ['foo' => 'bar'];\n    }\n}\n\n$aggregator = new ConfigAggregator([\n    ApplicationConfig::class,\n    new PhpFileProvider('*.global.php'),\n]);\nvar_dump($aggregator->getMergedConfig());  Output from both examples will be the same:  array(4) {\n  'foo' =>\n  string(3) \"bar\"\n  'db' =>\n  array(1) {\n    'dsn' =>\n    string(9) \"mysql:...\"\n  }\n  'cache_storage' =>\n  string(5) \"redis\"\n  'redis' =>\n  array(0) {\n  }\n}",
            "title": "Config providers"
        },
        {
            "location": "/config-providers/#generators",
            "text": "Config providers can be written as generators. This way, a single callable can\nprovide multiple configurations:  use Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\Stdlib\\Glob;\n\n$aggregator = new ConfigAggregator([\n    function () {\n        foreach (Glob::glob('data/*.global.php', Glob::GLOB_BRACE) as $file) {\n            yield include $file;\n        }\n    },\n]);\nvar_dump($aggregator->getMergedConfig());  The  PhpFileProvider  is implemented as a generator.",
            "title": "Generators"
        },
        {
            "location": "/config-providers/#available-config-providers",
            "text": "",
            "title": "Available config providers"
        },
        {
            "location": "/config-providers/#phpfileprovider",
            "text": "Loads configuration from PHP files returning arrays, such as this one:  return [\n    'db' => [\n        'dsn' => 'mysql:...',\n    ],    \n];  Wildcards are supported:  use Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new PhpFileProvider('config/*.global.php'),        \n    ]\n);  The example above will merge all matching files from the  config/  directory. If\nyou have files such as  app.global.php  or  database.global.php  in that\ndirectory, they will be loaded using this above lines of code.  The provider also supports  globbing .  Globbing defaults to PHP's  glob() \nfunction. However, if  Zend\\Stdlib\\Glob  is available, it will use that to allow\nfor cross-platform glob patterns, including brace notation: 'config/autoload/{{,*.}global,{,*.}local}.php' . Install zendframework/zend-stdlib  to\nutilize this feature.",
            "title": "PhpFileProvider"
        },
        {
            "location": "/config-providers/#zendconfigprovider",
            "text": "Sometimes using plain PHP files may be not enough; you may want to build your\nconfiguration from multiple files of different formats, such as INI, JSON, YAML,\nor XML.  zend-config-aggregator allows you to do so via its ZendConfigProvider . This feature requires first installing zend-config:  $ composer require zendframework/zend-config  Once installed, you may use as many  ZendConfigProvider  instances as you need:  use Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\ZendConfigProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new ZendConfigProvider('*.global.json'),\n        new ZendConfigProvider('database.local.ini'),\n    ]\n);  These could even be combined into a single glob statement:  $aggregator = new ConfigAggregator(\n    [\n        new ZendConfigProvider('*.global.json,database.local.ini'),\n    ]\n);  ZendConfigProvider  accepts wildcards and globs, and autodetects the config\ntype based on file extension.   Some config readers (in particular, YAML) may need additional dependencies;\nplease refer to  the zend-config manual \nfor more details.",
            "title": "ZendConfigProvider"
        },
        {
            "location": "/caching/",
            "text": "Caching\n\n\nMerging configuration on every request is not performant, particularly when\nusing many configuration files. As such, zend-config-aggregator also\nprovides the ability to enable a filesystem-based configuration cache.\n\n\nTo enable the configuration cache, pass a cache file name as the second\nparameter to the \nConfigAggregator\n constructor:\n\n\nuse Zend\\ConfigAggregator\\ArrayProvider;\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new ArrayProvider([ConfigAggregator::ENABLE_CACHE => true]),\n        new PhpFileProvider('*.global.php'),\n    ],\n    'data/config-cache.php'\n);\n\n\n\n\nWhen a cache file is specified, you will also need to add the\n\nconfig_cache_enabled\n key (which you can also specify via the\n\nConfigAggregator::ENABLE_CACHE\n constant) somewhere within one of your\nconfiguration providers, and set it to boolean \ntrue\n. Using this approach, if\nyou were to use the globbing pattern \n{{,*.}global,{,*.}local}.php\n (or similar)\nwith the \nPhpFileProvider\n, you could drop a file named \nenable-cache.local.php\n\ninto your production deployment with the following contents in order to enable\nconfiguration caching in production:\n\n\n<?php\nuse Zend\\ConfigAggregator\\ConfigAggregator;\n\nreturn [\n    ConfigAggregator::ENABLE_CACHE => true,\n];\n\n\n\n\nWhen caching is enabled, the \nConfigAggregator\n does not iterate config\nproviders. Because of that it is very fast, but after it is enabled, you cannot\nmake any changes to configuration without clearing the cache. \nCaching should\nbe used only in a production environment\n, and your deployment process should\nclear the cache.",
            "title": "Caching"
        },
        {
            "location": "/caching/#caching",
            "text": "Merging configuration on every request is not performant, particularly when\nusing many configuration files. As such, zend-config-aggregator also\nprovides the ability to enable a filesystem-based configuration cache.  To enable the configuration cache, pass a cache file name as the second\nparameter to the  ConfigAggregator  constructor:  use Zend\\ConfigAggregator\\ArrayProvider;\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n$aggregator = new ConfigAggregator(\n    [\n        new ArrayProvider([ConfigAggregator::ENABLE_CACHE => true]),\n        new PhpFileProvider('*.global.php'),\n    ],\n    'data/config-cache.php'\n);  When a cache file is specified, you will also need to add the config_cache_enabled  key (which you can also specify via the ConfigAggregator::ENABLE_CACHE  constant) somewhere within one of your\nconfiguration providers, and set it to boolean  true . Using this approach, if\nyou were to use the globbing pattern  {{,*.}global,{,*.}local}.php  (or similar)\nwith the  PhpFileProvider , you could drop a file named  enable-cache.local.php \ninto your production deployment with the following contents in order to enable\nconfiguration caching in production:  <?php\nuse Zend\\ConfigAggregator\\ConfigAggregator;\n\nreturn [\n    ConfigAggregator::ENABLE_CACHE => true,\n];  When caching is enabled, the  ConfigAggregator  does not iterate config\nproviders. Because of that it is very fast, but after it is enabled, you cannot\nmake any changes to configuration without clearing the cache.  Caching should\nbe used only in a production environment , and your deployment process should\nclear the cache.",
            "title": "Caching"
        }
    ]
}